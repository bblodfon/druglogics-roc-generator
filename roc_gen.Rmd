---
title: "Druglogics ROC curve Generator"
author: "[John Zobolas](https://github.com/bblodfon)"
output:
  html_document:
    df_print: paged
    theme: united
    toc: false
    toc_float: true
runtime: shiny
---

# Intro

With this code we can **generate a ROC curve** from one or two ensemble-wise 
synergy files, which is one of the output results of the druglogics pipeline 
module `drabme`.

# Prerequisites

```{r Load useful functions, message = FALSE}
source("useful_fun.R") # loads `dplyr`
library(plotly) # 4.8.0
library(DT) # 0.5
```

# Example Input

**Input files** that are needed in order to generate the ROC curve are:

- One **observed synergies file** to test against the synergies found from the 
`drabme` simulation(s)
- At least **one ensemble-wise synergy** result file
  - In case of one such file, the ROC curve can be drawn using either the 
  **original** synergy score results or the **random** ones
  - In case of two such files, the second (**random**) is used for normalizing 
  the results of the first (**original**) through various methods:
    - **exp-prod-norm**: $orig\cdot rand\Rightarrow exp(orig)\cdot exp(rand)=exp(orig+rand)$
    - **exp-fold-change-norm**: $orig/ rand\Rightarrow exp(orig)/ exp(rand)=exp(orig-rand)$

Check in the `input/` dir for example files and their format.  
In the next section we show how to create a combined `predictions` object from
such files:
```{r Input and validation}
input.dir = paste0(getwd(), '/input')
original.file = paste0(input.dir, "/ensemble_synergies")
random.file = paste0(input.dir, "/ensemble_synergies_random")
observed.synergies.file = paste0(input.dir, "/observed_synergies")

# load files
observed.synergies = get.observed.synergies(observed.synergies.file)
orig.res = read.ensemble.synergies.drame.file(original.file)
rand.res = read.ensemble.synergies.drame.file(random.file)

data.validation(orig.res, rand.res, observed.synergies)
predictions.example = 
  create.predictions.data.frame(orig.res, rand.res, observed.synergies)
```

You can of course use the rest of the code if you can create a `predictions` 
object yourself (with at least one of the `original` or `random` columns).  

Get a glimpse of the `predictions.example` data:
```{r Example predictions (embeded Sniny input and ouput), echo = FALSE}
numericInput(inputId = "rows", label = "How many rows to show?", value = 5,
             min = 0, max = nrow(predictions.example))

renderTable({
  head(predictions.example, n = input$rows)
}, digits = 7)
```

# Create ROC Curve

Choose a file with the observed synergies, at least one drabme output result 
file and the method to calculate the ROC statistics.  
By default, we draw the ROC curve for the example input from above:

```{r ROC shiny app, echo = FALSE}
ui = fluidPage(
  sidebarLayout(
    sidebarPanel(width = 5,
      selectInput(inputId = "method", label = "Select Method", 
                  choices = c("original", "random", "exp-prod-norm", 
                              "exp-fold-change-norm")), 
      fileInput(inputId = "observed", label = "Select Observed Synergies File", 
                buttonLabel = "Browse...", placeholder = "No file selected"),
      fileInput(inputId = "orig", label = "Select Original Ensemble Synergies File", 
                buttonLabel = "Browse...", placeholder = "No file selected"),
      fileInput(inputId = "rand", label = "Select Random Ensemble Synergies File", 
                buttonLabel = "Browse...", placeholder = "No file selected")
      ),
    mainPanel(plotlyOutput(outputId = "rocPlot"), width = 7)
  ),
  basicPage(DT::dataTableOutput(outputId = "rocStatsTable"))
)

server = function(input, output) {
  
  get.method.reactive = reactive({
    method = input$method
  })
  
  get.roc.stats.reactive = reactive({
    method = get.method.reactive()
    observed.synergies.file = input$observed$datapath
    original.file = input$orig$datapath
    random.file = input$rand$datapath
  
    # which `predictions` object to use?
    if (!is.null(observed.synergies.file) & (!is.null(original.file) |
                                             !is.null(random.file))) {
      # we generate new `predictions`
      observed.synergies = get.observed.synergies(observed.synergies.file)
      orig.res = read.ensemble.synergies.drame.file(original.file)
      rand.res = read.ensemble.synergies.drame.file(random.file)
  
      data.validation(orig.res, rand.res, observed.synergies)
      predictions = create.predictions.data.frame(orig.res, rand.res, observed.synergies)
    }
    else {
      # use example `predictions`
      predictions = predictions.example
    }
  
    # validate if input method is combatible with `predictions` data
    method.check(method, predictions)
    method.column = map.method.to.column(method)
  
    # normalize
    predictions = normalize(predictions)
  
    # generate ROC stats
    roc.stats = gen.roc.stats(predictions, method.column)
  })
  
  output$rocPlot = renderPlotly({
    method = get.method.reactive()
    roc.stats = get.roc.stats.reactive()
    
    x = roc.stats$FPR
    y = roc.stats$TPR
    auc = sum(diff(x) * (head(y,-1)+tail(y,-1)))/2
  
    # old-styled plot (use with `renderPlot` and `plotOutput`)
    # plot.roc(x, y, auc, method)
  
    plotly.roc(roc.stats, auc, method)
  })
  
  output$rocStatsTable = DT::renderDataTable({
    roc.stats = get.roc.stats.reactive()
  })
}

shinyApp(ui, server, options = list(height = 1000, width = 1200))
```